\documentclass[12pt,titlepage,a4page , tikz , multi,table , svgnames,xcdraw]{article}
\usepackage{graphicx}
\usepackage[svgnames , table , xcdraw]{xcolor} 
\usepackage{fancyhdr}
 
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{mathtools}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{float}
\usepackage{enumitem}
\usepackage{listings }
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{afterpage}
\usepackage{amssymb}
\usepackage{pdflscape}
\usepackage{lscape}
\usepackage{amsmath}
\usepackage{svg}
\usepackage[final]{pdfpages}
\usepackage[nottoc]{tocbibind}
\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}
\usetikzlibrary{shapes.multipart}


\DeclareMathOperator\arctanh{arctanh}

\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage{PTSerif} 

\usepackage{float}

\usepackage[Kashida]{xepersian}
\settextfont[
 BoldFont={XB NiloofarBd.ttf}
 ]{XB Niloofar.ttf}


\NewDocumentCommand{\codeword}{v}{
\texttt{\textcolor{blue}{#1}}
}
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal


\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\hypersetup{citecolor=blue}

\newcommand\independent{\protect\mathpalette{\protect\independenT}{\perp}}
\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

\newenvironment{changemargin}[2]{%
\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{#1}%
\setlength{\rightmargin}{#2}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{\parskip}%
}%
\item[]}{\end{list}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


\begin{document}

\begin{titlepage}

 \begin{center}
        
       \vspace*{0.5cm}

 \vspace{0.5cm}
       \textbf{ \Huge{به نام خدا} }
       \vspace{0.2cm}
       
       \includegraphics[width=0.4\textwidth]{sharif1.png}
       
 	\vspace{0.3cm}
       \textbf{ \LARGE{طراحی سیستم‌های دیجیتال} }

 
   \vspace{0.3cm}
  \textbf{ \Large{ پروژه پایانی - CORDIC} }
   \vspace{0.3cm}
       
 
      \large \textbf{دانشکده مهندسی کامپیوتر}\\\vspace{0.2cm}
    \large   دانشگاه صنعتی شریف\\\vspace{0.25cm}
      
استاد:\\
    \textbf{{جناب آقای دکتر بهاروند}}

    \vspace{0.15cm}
    \noindent\rule[1ex]{\linewidth}{3pt}
    
    \vspace{0.5cm}
نام، نام خانوادگی و شماره دانشجویی اعضای گروه:\\
    
    \textbf{{علیرضا ایلامی - 97101286}}
        \vspace{0.05cm}
        
     
        \textbf{{محمدمتین فتوحی - 97106143}}
        \vspace{0.05cm}
        
        \textbf{{سید مهدی فقیه - 97106198}}
        \vspace{0.05cm}
        
           \textbf{{علی قاسمی - 97106205}}
        \vspace{0.05cm}
        
        
        \textbf{{امیرمهدی نامجو - 97107212}}
        \vspace{0.05cm}
        
       \textbf{{محمدرضا یوسف پور -  97106324}}
        \vspace{0.05cm}


\end{center}
\end{titlepage}

\newpage
\pagestyle{fancy}
\fancyhf{}
\fancyfoot{}

\cfoot{\thepage}
\chead{پروژه پایانی}
\rhead{CORDIC}
\lhead{طراحی سیستم‌های دیجیتال}

\tableofcontents

\newpage

\section{مقدمه}

\subsection{معرفی اجمالی و تاریخچه}
هدف اصلی ما در این پروژه، طراحی یک واحد CORDIC است. CORDIC مخفف واژه \lr{COordinate Rotation DIgital Computer} به معنی کامپیوتر دیجیتیال چرخش مختصاتی است. این الگوریتم اولین بار در سال 1956 توسط آقای جک ولدر (\lr{Jack E. Volder})،‌ که یک مهندس اویونیک (مهندس الکترونیک مرتبط به صنعت هوانوردی) بود،‌ برای سیستم مسیریابی بمب افکن B-58 ابداع شد. هر چند بعضی از ایده های استفاده شده در این روش،‌ حتی در قرن هفدهم ذکر شده بودند. ویژگی اصلی این الگوریتم هم این است که امکان پیاده سازی آن با عناصر ساده جمع کننده و شیفت دهنده وجود دارد و نیازی به استفاده از واحد های پیشرفته تر نظیر ضرب کننده وجود ندارد. همچنین باید توجه کرد که در زمان ساخت و توسعه این الگوریتم، کامپیوتر واژه ای برای اشاره به دستگاه محاسبه گر بوده است و کامپیوتر با آن مفهوم سیستم متشکل از پردازنده و حافظه و مفاهیم مطرح شده توسط تورینگ، هر چند وجود داشت،‌ اما هنوز کاربرد آن گسترده نشده بود. از این رو نباید لغت کامپیوتر در نام این الگوریتم را با تعریف امروزی آن اشتباه گرفت. \cite{birth} \cite{volder}



\subsection{هدف الگوریتم}
الگوریتم CORDIC در شکل ساده و رایج خود،‌ الگوریتمی برای محاسبه مقادیر توابع مختلف علی الخصوص توابع مثلثاتی و هذلولوی است. از الگوریتم CORDIC در مواردی برای محاسبه توابع لگاریتمی،‌ جذر گرفتن و موارد نظیر این هم استفاده می شود اما شکل اولیه آن مبتنی بر همان توابع مثلثاتی است.

در اصل الگوریتم اصلی که در این جا قصد پیاده سازی آن را داریم،‌ دو حالت عملکردی مختلف دارد. حالت Rotation و حالت \lr{Vectoring}. در حالت \lr{Rotation}، یک بردار همراستا با محور $x$ و همچنین یک زاویه به الگوریتم داده شده و این الگوریتم، در اثر چرخش های متوالی در مراحل پشت سرهم، بردار اولیه را می چرخاند تا در نهایت برآیند تمامی این چرخش ها،‌ با دقت مشخصی برابر با زاویه داده شده به برنامه بشود. در حالت \lr{Vectoring}، یک بردار دلخواه داده می شود و الگوریتم سعی می کند در اثر چرخش های متوالی و منظم، مولفه $y$ بردار را از بین ببرد و آن را بر محور $x$ منطبق کند. با این کار، از طریق مولفه $x$ نهایی می توان اندازه بردار اولیه را بدست آورد و همچنین با بررسی روند چرخش های انجام شده،‌ می توان به زاویه بردار اولیه هم پی برد. \cite{volder} \cite{lakshmi} \cite{andraka}


\newpage

\subsection{پایه ریاضی}

\subsubsection{حالت Rotation}
ابتدا باید به نحوه مدل کردن چرخش یک نقطه در دستگاه مختصات بپردازیم. اگر نقطه $v = (x , y)$ را به اندازه زاویه $\theta$ به صورت پادساعتگرد (در جهت مثلثاتی) دوران بدهیم، نقطه $v' = (x' , y')$ به صورت زیر بدست می آید:

$$x' = x \cos(\theta) - y \sin(\theta)$$
$$y' = x \sin (\theta) + y \cos (\theta) $$

از طرف دیگر، یک دوران به اندازه $\theta$ را می توان مجموعی از $n$ دوران دیگر $\theta_1 , \theta_2 , \cdots , \theta_n$ دانست که $\theta = \theta_1 + \theta_2 + \cdots \theta_n$

در نتیجه می توان برای انجام یک دوران، آن را به چشم تعدادی دوران دیگر دانست و با نماد گذاری نقطه شروع به شکل $v_0 = (x_0 , y_0)$ و نتیجه هر کدام از $n$ دوران به صورت $v_i = (x_i , y_i)$ داریم:

$$x_{i+1} = x_{i} \cos(\theta_{i+1}) - y_{i} \sin(\theta_{i+1})$$
$$y_{i+1} = x_{i} \sin (\theta_{i+1}) + y_{i} \cos (\theta_{i+1}) $$

از طرف دیگر، با فاکتور گرفتن از $\cos(\theta_{i+1}$ در عبارات بالا داریم:

$$x_{i+1} =\cos(\theta_{i+1})( x_{i}  - y_{i} \tan(\theta_{i+1}))$$
$$y_{i+1} = \cos(\theta_{i+1})(x_{i} \tan (\theta_{i+1}) + y_{i}  (\theta_{i+1})) $$

اگر عبارت شامل $\cos$ را کنار بگذاریم، درون پرانتز شاهد یک جمع (تفریق) و یک ضرب هستیم. در سخت افزار ضرب به حالت کلی، هزینه نسبتا بالایی دارد؛ اما الگوریتم CORDIC سعی می کند با ایده هوشمندانه ضرب در توان های $2$ این مشکل را برطرف کند. زوایایی که قرار است برای چرخش ها انتخاب بشوند، باید به این صورت باشند که:

$$\tan (\theta_{i+1}) = \pm 2^{-i}$$

از آن جایی که عملیات های ضرب یا تقسیم بر توان های $2$ در یک سیستم دیجیتالی به راحتی از طریق شیفت دادن قابل انجام است، بدون نیاز به استفاده از ضرب کننده، می توانیم عملیات ها را انجام بدهیم.

نکته مهمی که باقی می ماند، کسینوس هایی است که در هر مرحله در حال ضرب شدن هستند. ابتدا باید توجه کرد که:

$$\cos (\arctan (2 ^{-i})) = \frac{1}{\sqrt{1 + 2^{-i}}}$$

در نتیجه، در اصل بسته به این که قرار است این محاسبات تا چند مرحله ادامه پیدا کنند، عدد ضرب شده نهایی به صورت:

$$K = \prod_{i} \frac{1}{\sqrt{1 + 2^{-2i}}}$$

خواهد بود.


جدول محاسبات مربوط به $K$ در زیر آمده است:

$$\begin{array}{c|c|c|c|c}
{i} & {2^{-i}} & {\arctan(2^{-i})} & {\cos(\arctan(2^{-i}))} & \prod_{i} \cos(\arctan(2^{-i})) \\
 0 &  1.0000 &  0.7854 &  0.7071 &  0.7071\\
  1 &  0.5000 &  0.4636 &  0.8944 &  0.6325\\
  2 &  0.2500 &  0.2450 &  0.9701 &  0.6136\\
  3 &  0.1250 &  0.1244 &  0.9923 &  0.6088\\
  4 &  0.0625 &  0.0624 &  0.9981 &  0.6076\\
  5 &  0.0312 &  0.0312 &  0.9995 &  0.6074\\
  6 &  0.0156 &  0.0156 &  0.9999 &  0.6073\\
  7 &  0.0078 &  0.0078 &  1.0000 &  0.6073\\
  8 &  0.0039 &  0.0039 &  1.0000 &  0.6073\\
  9 &  0.0020 &  0.0020 &  1.0000 &  0.6073\\
  10 &  0.0010 &  0.0010 &  1.0000 &  0.6073\\
  11 &  0.0005 &  0.0005 &  1.0000 &  0.6073\\
  12 &  0.0002 &  0.0002 &  1.0000 &  0.6073\\
  13 &  0.0001 &  0.0001 &  1.0000 &  0.6073\\
  14 &  0.0001 &  0.0001 &  1.0000 &  0.6073\\
  15 &  0.0000 &  0.0000 &  1.0000 &  0.6073

\end{array}$$

همان طور که مشخص است، با دقت چهار رقم اعشار سری مذکور به $0.6073$ همگراست. با کمک نرم افزارهای ریاضیاتی نظیر Mathematica نیز می توان بررسی کرد که:

$$\lim_{n \to \infty}  \prod_{i=0}^{n} \frac{1}{\sqrt{1 + 2^{-2i}}} \approx 0.607253 \approx 0.6073$$

همان طور که در بالا دیدیم:

$$\tan (\theta_{i+1}) = \pm 2^{-i}$$

یعنی دو مقدار مثبت و منفی وجود دارد و زاویه هم می تواند به دو شکل مختلف مثبت و منفی باشد. برای این که بدانیم در هر مرحله، باید مقدار مثبت زاویه را اعمال کنیم یا مقدار منفی آن را باید به این توجه کنیم که ما در این جا با زوایایی با مقادیر مشخص سر و کار داریم و در ابتدا هم یک زاویه به عنوان زاویه هدف در نظر داریم که هر بار با اجرای یکی از مراحل، می توانیم زاویه هدف را کاهش داده و به مقدار جدید آپدیت کنیم. حال اگر مقدار زاویه هدف باقی مانده مثبت باشد، باید با کم کردن یک زاویه مثبت، آن را به صفر نزدیک کنیم و اگر منفی باشد، با کم کردن یک زاویه منفی، آن را به صفر نزدیک نماییم.

در نتیجه فرمول کلی الگوریتم به صورت زیر در می آید:

$$x_{i+1}=x_{i}- d_{i} \cdot y_{i} \cdot 2^{-i}$$

$$\begin{array}{c}
y_{i+1}=y_{i}+d_{i} x_{i} 2^{-i} \\
\theta_{i+1}=\theta_{i}-d_{i} \arctan(2^{-i})
\end{array}$$

که در آن اگر $z_i$ نامنفی باشد، مقدار $d_i$ برابر 1 و در غیر این صورت برابر $-1$ است.

چند نکته در این جا باقی می ماند. اولین مورد این است که بازه برد $\arctan$ در
$\frac{-\pi}{2} < \theta < \frac{\pi}{2}$
است. برای این که عملیات چرخش برای زوایای بیش تر از $\frac{\pi}{2}$ و کمتر از 
$\frac{-\pi}{2}$
هم به خوبی جواب بدهد، باید دوران ناشی از $\frac{\pi}{2}$ ای که این زاویه ها اضافه یا کم دارند را در همان ابتدا اعمال کنیم.
برای این کار، اگر 
$\theta > \frac{\pi}{2}$
باشد، در همان ابتدا تبدیل زیر را اعمال می کنیم:
$$x' = -y , y' = x , \theta' = \theta - \frac{\pi}{2}$$
و اگر $\theta < \frac{-\pi}{2}$ باشد، در همان ابتدا تبدیل:
$$x' = y , y' = -x , \theta' = \theta + \frac{\pi}{2}$$
را اعمال می کنیم و الگوریتم را با $x' , y' , \theta'$ ادامه می دهیم.

نکته دیگر مربوط به این است که دو شکل دیگر از الگوریتم CORDIC به نام های Hyperbolic و Linear یعنی هذلولوی و خطی وجود دارند و شکلی که در بالا آن را توصیف کردیم، شکل Circular یا دایروی آن بود. منطق کلی این روش ها مشابه بالا است، با این تفاوت که در شکل هذلولوی، از توابع هذلولوی استفاده شده و در شکل خطی، عملا به جای $\arctan(2^{-i})$ خود $2^{-i}$ قرار می گیرد. به جز این، این دو روش تنها در منفی یا مثبت بودن یکسری از عبارات با هم تفاوت دارند که به صورت خلاصه و به شکل متحدالشکل، می توان آن را به صورت زیر نمایش داد.

$$x_{i+1}=x_{i}- \eta \cdot d_{i} \cdot y_{i} \cdot 2^{-i}$$

$$\begin{array}{c}
y_{i+1}=y_{i}+d_{i} x_{i} 2^{-i} \\
\theta_{i+1}=\theta_{i}-d_{i} \cdot \xi_i \\
\end{array}$$

که $\eta$ و $\xi$ براساس جدول زیر هستند:

$$\begin{array}{|c|c|c|}
\hline \text { Mode } & \eta & \xi \\
\hline \text {Linear} & 0 & 2^{-i} \\
\hline \text {Circular} & 1 & \tan ^{-1}\left(2^{-i}\right) \\
\hline \text {Hyperbolic} & -1 & \tanh ^{-1}\left(2^{-i}\right) \\
\hline
\end{array}$$


در نهایت هم بعد از اعمال همه مراحل، باید $x$ و $y$ نهایی در ضریب $K$ که بالا نوشته شد، ضرب بشوند. این ضریب برای حالت هذلولوی، برابر $K = 1.2075$ و برای حالت خطی $K=1$ است.

در نهایت لازم به ذکر است که هر چند الگوریتم چرخش، می تواند هر بردار اولیه ای را بچرخاند، اما در شکل استاندارد الگوریتم، بردار اولیه به صورت یکه و موازی محور $x$ داده می شو. در دو جدول زیر، این که ورودی ها و خروجی های هر کدام از این حالات در وضعیت استاندارد چه هستند، نمایش داده شده است:

\begin{center}
جدول ورودی های استاندارد:
\end{center}
$$\begin{array}{|c|c|c|c|}
\hline \text { Mode } & x_{\text {input}} & y_{\text {input}} & \theta_{\text {input}} \\
\hline \text {Linear} & \mathrm{x} & 0 & \mathrm{\theta} \\
\hline \text {Circular} & 1 & 0 & \mathrm{\theta} \\
\hline \text {Hyperbolic} & 1 & 0 & \mathrm{\theta} \\
\hline
\end{array}$$
\\
\\
\begin{center}
جدول خروجی های استاندارد:
\end{center}
$$\begin{array}{|c|c|c|c|}
\hline \text { Mode } & x_{\text {output}} & y_{\text {output}} & \theta_{\text {output}} \\
\hline \text {Linear} & x & x \times \theta & 0 \\
\hline \text {Circular} & \cos (\theta) & \sin (\theta) & 0 \\
\hline \text {Hyperbolic} & \cosh (\theta) & \sinh (\theta) & 0 \\
\hline
\end{array}$$

\subsubsection{حالت Vectoring}

پایه و اساس حالت Vectoring از نظر ریاضیاتی مشابه حالت Rotation است. با این تفاوت که در حالت Rotation ما قصد داشتیم یک بردار را به اندازه زاویه مشخص شده بچرخانیم، اما این جا قصد داریم یک بردار را طوری بچرخانیم که روی محور $x$ منطبق شده و در نتیجه این چرخش ها اندازه و زاویه اولیه اش با محور $x$ را پیدا کنیم. از نظر ریاضیاتی، همه مواردی که در بخش قبل گفته شده، در این جا هم برقرار است. فقط در این جا باید توجه کرد که در ابتدای کار، ما زاویه ای در اختیار نداریم و در عوض باید با استفاده از $x$ و $y$ داده شده، این زاویه را پیدا کنیم. مشابه بخش قبل، اساس کلی این الگوریتم هم براساس زوایا و بردارهای ناحیه اول و چهارم مختصات است. در نتیجه، اضافه کردن زوایا، بر این اساس انجام می شود که آیا $y$ بردار فعلی، مثبت است یا منفی، اگر منفی باشد، با افزایش زاویه و اگر مثبت باشد، با کاهش زاویه رو به رو هستیم. در اصل تفاوت اصلی این الگوریتم با الگوریتم بخش قبل، در مقدار $d_i$ است که به شکل زیر مشخص می شود:

$$d_{i}=\left\{\begin{array}{ll}
1 & \text { if } y_{i}<0 \\
-1 & \text { if } y_{i} \geq 0
\end{array}\right.$$

\newpage
معادلات اصلی الگوریتم، همان معادلات قبلی است:

$$x_{i+1}=x_{i}- \eta \cdot d_{i} \cdot y_{i} \cdot 2^{-i}$$

$$\begin{array}{c}
y_{i+1}=y_{i}+d_{i} x_{i} 2^{-i} \\
\theta_{i+1}=\theta_{i}-d_{i} \ cdot \xi_i \\
\end{array}$$


در حالاتی که ورودی و خروجی در ناحیه اول یا چهارم نباشند، تبدیل هایی مانند تبدیل های بخش قبل صورت می گیرد، با این تفاوت که در این جا، معیار ما مثبت یا منفی بودن $x$ و $y$ است. اگر $x$ منفی و $y$ مثبت باشد یعنی در ناحیه دوم هستیم و تبدیل زیر اعمال می شود:
$$x' = y , y' = -x , \theta' =  \frac{\pi}{2}$$
و اگر $x$ منفی و $y$ هم منفی باشد، یعنی در ناحیه سوم هستیم و تبدیل زیر اعمال می شود:
$$x' = -y , y' = x , \theta' =  \frac{-\pi}{2}$$
توجه داشته باشید که در این حالت، در ابتدا $\theta =0$ است، چون چیزی در مورد زاویه نمی دانیم و هدف پیدا کردن زاویه است. بعد از انجام تبدیلات، الگوریتم را با استفاده از $x' , y' , \theta'$ پی می گیریم.


جدول ورودی و خروجی های استاندارد این حالت به صورت زیر است:


\begin{center}
جدول ورودی های استاندارد:
\end{center}
$$\begin{array}{|c|c|c|c|}
\hline \text { Mode } & x_{\text {input}} & \text {yinput} & \theta_{\text {input}} \\
\hline \text {Linear} & x & y & 0 \\
\hline \text {Circular} & x & y & 0 \\
\hline \text {Hyperbolic} & x & y & 0 \\
\hline
\end{array}$$
\\
\\
\begin{center}
جدول خروجی های استاندارد:
\end{center}

$$\begin{array}{|c|c|c|c|}
\hline \text { Mode } & x_{\text {output}} & y_\text{output} & \theta_{\text {output}} \\
\hline \text {Linear} & x & 0 & \frac{y}{x} \\
\hline \text {Circular} & \sqrt{x^{2}+y^{2}} & 0 & \tan ^{-1} \frac{y}{x} \\
\hline \text {Hyperbolic} & \sqrt{x^{2}-y^{2}} & 0 & \tanh ^{-1} \frac{y}{x} \\
\hline
\end{array}$$


منابع استفاده شده برای بخش مربوط به پایه ریاضی:
\cite{lakshmi} \cite{andraka}     \cite{evaluation}
 
 
\newpage

\subsection{شکل دقیق الگوریتم}

در الگوریتم های زیر، $\theta$ را با $z$ نمایش داده ایم. الگوریتم ها براساس حالت Circular نوشته شده اند ولی تنها تفاوت دو حالت دیگر، همان طور که در بالا هم گفته شده، در علامت مثبت و منفی یکی از عبارات و همچنین استفاده از تابعی متفاوت با $\arctan$ است. ضمنا بهینه سازی های پیاده سازی سخت افزاری (نظیر این که عملا از یک $K$ ثابت استفاده خواهیم کرد) در زیر اعمال نشده و شکل کلی الگوریتم نوشته شده است. \cite{andraka}

\begin{latin}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\SetAlgoLined
\Input{$x_{in}$,$~~y_{in}$,$~~z_{in}$:angle,$~~n$:number-of-iterations}
\Output{$x_{out}$ , $y_{out}$}

  \eIf{$ ! (\frac{-\pi}{2} < z_{in} < \frac{\pi}{2})$}{
  \eIf{$z_{in} > \frac{\pi}{2}$}{
  $x = -y_{in}$\;
  $y = x_{in}$\;
  $z = z_{in} - \frac{\pi}{2}$\;
  }{
  $x = y_{in}$\;
  $y = -x_{in}$\;
  $z = z_{in} + \frac{\pi}{2}$\;
  }
   }{
   $x = x_{in}$\;
   $y = y_{in}$\;
   $z = z_{in}$\;
  }
  $K = 1$\;
  \For{$i\leftarrow 0$ \KwTo $n$}{
  $ d= sgn(z)$\;
  $x=x - d \cdot y \cdot 2^{-i}$ \;
  $y = y + d \cdot x \cdot \cdot 2^{-i}$ \;
  $z = z + d \cdot \arctan(2^{-i})$\;
  $K = K \cdot \frac{1}{\sqrt{1 + 2^{- 2 i}}}$\;
  
  }
  
  $x_{out} = \frac{x}{K}$\;
  $y_{out} = \frac{y}{K}$\;
 
 \caption{CORDIC Rotation}
\end{algorithm}
\end{latin}

\newpage


\begin{latin}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\SetAlgoLined
\Input{$x_{in}$,$~~y_{in}$,$~~z_{in}$:angle,$~~n$:number-of-iterations}
\Output{$x_{out}$ , $z_{out}$}

  \eIf{$ x_{in}<0$}{
  \eIf{$y_{in}\geq 0$}{
  $x = y_{in}$\;
  $y = -x_{in}$\;
  $z = +\frac{\pi}{2}$\;
  }{
  $x = -y_{in}$\;
  $y = x_{in}$\;
  $z = - \frac{\pi}{2}$\;
  }
   }{
   $x = x_{in}$\;
   $y = y_{in}$\;
   $z = 0$\;
  }
  $K = 1$\;
  \For{$i\leftarrow 0$ \KwTo $n$}{
  $ d= sgn(y)$\;
  $x=x - d \cdot y \cdot 2^{-i}$ \;
  $y = y + d \cdot x \cdot \cdot 2^{-i}$ \;
  $z = z + d \cdot \arctan(2^{-i})$\;  
  $K = K \cdot \frac{1}{\sqrt{1 + 2^{- 2 i}}}$\;
  }
  
  $x_{out} = \frac{x}{K}$\;
  $z_{out} = z$\;
 
 \caption{CORDIC Vectoring}
\end{algorithm}
\end{latin}

\newpage

\subsection{کاربردها}

\subsubsection{سخت افزار}

یکی از اولین کاربردهای اصلی و واقعی الگوریتم CORDIC، استفاده از آن در سیستم مسیریابی و ناوبری ماه‌نورد ناسا در پروژه Apollo در حدود سال های 1971 و 1972 میلادی بوده است که از آن برای سیستم های محاسبه زاویه افقی نسبت به اشیا و همچنین محاسبه فاصله تا سفینه اصلی استفاده شده است. \cite{lunar}

به عنوان کاربرد عمومی، CORDIC در سیستم هایی که نیاز به محاسبه توابع مثلثاتی داشته باشند، ولی به دلایلی نظیر هزینه، امکان استفاده از ضرب کننده در آن ها وجود نداشته باشد، کاربرد به سزایی دارد. در صورتی که بتوان از ضرب کننده استفاده کرد، محاسبه این توابع به کمک بسط تیلور و مک لورن آن ها در ترکیب با \lr{Lookup Table} معمولا سریع تر از CORDIC است ولی اگر امکان استفاده از ماژول ضرب کننده مجزا نباشد، CORDIC به مراتب نسبت به پیاده سازی نرم افزاری ضرب و سپس استفاده از ضرب، برتری دارد و با سرعت بیش تری امکان انجام محاسبات را فراهم می آورد. همچنین در مواقعی که سعی بر کمینه کردن تعداد گیت های استفاده شده باشد و از این رو بخواهیم از ضرب کننده استفاده نکنیم (مثلا در یک سیستم پیاده شده روی FPGA) استفاده از CORDIC می تواند مورد توجه قرار بگیرد.



\subsubsection{نرم افزار}

در دورانی که CPU ها واحد Floating-Point مجزا نداشتند و تمامی رجیسترهای آنان، به صورت Integer بودند، شرکت های تولید کننده پردازنده در قالب کتابخانه های نرم افزاری مربوط به پیاده سازی \lr{IEEE Floating Point System} که امکان انجام محاسبات Floating-Point را از طریق رجیسترهای Integer مهیا می کرد، الگوریتم CORDIC را هم به صورت نرم افزاری برای محاسبه زوایای مثلثاتی پیاده سازی می کردند، اما بعدها که واحد های مجزای Floating-Point و محاسبات آن به صورت سخت افزاری به پردازنده ها استفاده شد، استفاده از CORDIC به این شیوه منسوخ شد و تنها در سیستم هایی که از نظر زمانی و Real-Time بودن محدودیت های ویژه ای دارند، از آن استفاده می شود. \cite{wikipedia}


\newpage


\section{پیاده سازی}
\subsection{اسامی ماژول ها و اینترفیس های سیستم}

\subsubsection{Vectoring}


 
 مازول \lr{Quadrant\_Corrector} 

 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] x,
input [31:0] y,
input[31:0] angle,
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
output reg [31:0] x_out,
output reg [31:0] y_out,
output reg [31:0] angle_out
\end{verbatim}
\end{latin}

\hrulefill


ماژول  \lr{Scaler} 
 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] number,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] answer
\end{verbatim}
\end{latin}

\hrulefill


ماژول  \lr{X\_Calculator}

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [1:0] mode,
input [31:0] y_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] x_out
\end{verbatim}
\end{latin}


\hrulefill
 

ماژول  \lr{Y\_Calculator}
 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [31:0] x_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] y_out
\end{verbatim}
\end{latin}


\hrulefill


ماژول \lr{Z\_Calculator}

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] angle,
input [31:0] y,
input [31:0] lookup_table_amount,
input clock,
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
 output wire [31:0] angle_out
\end{verbatim}
\end{latin}

\hrulefill


 ماژول اصلی  \lr{CORDIC\_Vector.v} 

\begin{latin}
\begin{verbatim}
input signed [31:0] x,
input signed [31:0] y,
input signed [31:0] angle,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
 output wire signed [31:0] rotated_x,
 output wire signed [31:0] rotated_y,
 output wire signed [31:0] final_angle
\end{verbatim}
\end{latin}


پارامتر برنامه هم:

\begin{latin}
\begin{verbatim}
parameter NUMBER_OF_ITERATIONS = 17;
\end{verbatim}
\end{latin}


\newpage
\subsubsection{Rotation}



 مازول \lr{Quadrant\_Corrector} 

 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] x,
input [31:0] y,
input[31:0] angle,
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
output reg [31:0] x_out,
output reg [31:0] y_out,
output reg [31:0] angle_out
\end{verbatim}
\end{latin}

\hrulefill


ماژول  \lr{Scaler} 
 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] number,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] answer
\end{verbatim}
\end{latin}

\hrulefill


ماژول  \lr{X\_Calculator}

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [1:0] mode,
input [31:0] y_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] x_out
\end{verbatim}
\end{latin}


\hrulefill
 

ماژول  \lr{Y\_Calculator}
 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [31:0] x_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] y_out
\end{verbatim}
\end{latin}


\hrulefill


ماژول \lr{Z\_Calculator}

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] angle,
input [31:0] y,
input [31:0] lookup_table_amount,
input clock,
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
 output wire [31:0] angle_out
\end{verbatim}
\end{latin}

\hrulefill


 ماژول اصلی  \lr{CORDIC\_Rotation} 

\begin{latin}
\begin{verbatim}
input signed [31:0] x,
input signed [31:0] y,
input signed [31:0] angle,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
 output wire signed [31:0] rotated_x,
 output wire signed [31:0] rotated_y,
 output wire signed [31:0] final_angle
\end{verbatim}
\end{latin}


پارامتر برنامه هم:

\begin{latin}
\begin{verbatim}
parameter NUMBER_OF_ITERATIONS = 29;
\end{verbatim}
\end{latin}



\newpage

\subsection{دیاگرام های بلوکی}


دیاگرام های بلوکی از صفحه بعد قرار گرفته اند. به ترتیب ابتدا دیاگرام های بلوکی مربوط به Vectoring و سپس Rotation قرار گرفته اند. در صفحه اول هر کدام، ماژول ها و ورودی-خروجی هایشان قرار گرفته و صفحه بعدی، اتصالات درونی آن ها.

\newpage

\begin{landscape}

\thispagestyle{empty}

\includepdf[pages=1,angle=90, ]{CORDICVECTOR.pdf}


\end{landscape}


\newpage

\begin{landscape}

\thispagestyle{empty}

\includepdf[pages=1,angle=90, ]{CORDICROTATION.pdf}


\end{landscape}
\newpage

\subsection{شرح وظایف ماژول ها}

در فایل های قرار داده شده، دو پوشه جدا داریم. یکی Rotation و دیگری Vectoring که هر کدام مختص به پروژه مربوط به خود هستند. البته ساختار بسیاری از ماژول های آنان، مشابه است اما از آن جایی که دو پروژه مجزا بودند، ما هم آنان را به صورت دو پوشه و پروژه مجزا قرار داده ایم. اما پیش از توضیح در مورد خود ماژول ها، باید در مورد نحوه انکود کردن اعداد به صورت باینری توضیح داده بشود.

برای انکود کردن زاویه ها، آن ها را بر $360$ تقسیم کرده و سپس در $2^{31}$ ضرب می کنیم و عدد حاصل را به صورت $32$ بیتی نمایش می دهیم. یعنی با فرمول زیر:
$$\frac{\text{Angle}}{360} \times 2^{31} \rightarrow 32 ~~\text{\lr{bit binary number}}$$
 مثلا زوایای $45$ درجه، $135$ درجه، $225$ درجه و $315$ درجه، به شکل زیر می شوند:

\begin{latin}
\begin{verbatim}

 45 deg: 32'b00010000000000000000000000000000
135 deg: 32'b00110000000000000000000000000000
225 deg: 32'b01010000000000000000000000000000
315 deg: 32'b01110000000000000000000000000000

\end{verbatim}
\end{latin} 

برای تبدیل برعکس آن هم عدد باینری را به صورت یک Integer در نظر می گیریم و عدد بدست آمده را بر $2^{31}$ تقسیم کرده و ضربدر $360$ می کنیم.


دلیل این که ضرب را در $2^{31}$ انجام دادیم و نه $2^{32}$، این است که در حالت Linear نیاز به  تبدیل عدد $2^{0}$ به مقیاس انکود شده در بالا بدست می آمده است و اگر در $2^{32}$ ضرب انجام می شد، با مشکل Overflow رو به رو می شدیم.

اعداد $x$ و $y$ هم به شکل Fixed-Point با $12$ رقم صحیح و $20$ رقم اعشاری انکود شده اند. در نتیجه برای تبدیل یک عدد به حالت نمایش داده شده $32$ بیتی باید از فرمول زیر استفاده کرد:

$$\text{Number} \times 2^{20} \rightarrow 32 ~~\text{\lr{bit binary number}}$$

و برای تبدیل برعکس هم باید عدد باینری $32$ بیتی گرفته شده را به صورت Integer در نظر گرفته و بر $2^{20}$ تقسیم کرد.

مثلا عدد $120$، $2$ و $170.5$ در این انکودینگ به شکل زیر نمایش داده می شود.
 
 
 \begin{latin}
\begin{verbatim}

  120: 32'b000001111000\_00000000000000000000
    2: 32'b000000000010\_00000000000000000000
170.5: 32'b000010101010\_10000000000000000000
\end{verbatim}
\end{latin} 

 
\subsubsection{Vectoring}

قبل از اشاره به ماژول های اصلی پروژه، می بایست به فایل ثوابت یا \lr{CONSTANTS.v} اشاره کنیم. در این فایل از طریق \lr{`define} سه ثابت به صورت زیر تعریف شده است:
\begin{latin}
\begin{verbatim}
`define CIRCULAR 2'b01
`define LINEAR 2'b00
`define HYPERBOLIC 2'b11
\end{verbatim}
\end{latin}

این فایل از طریق \lr{`include} در سایر ماژول ها قرار گرفته است.

ماژول ها را در دادامه به ترتیب Bottom-Up شرح می دهیم.

اولین ماژول \lr{Quadrant\_Corrector} است که در فایل هم نام خودش قرار دارد. 

 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] x,
input [31:0] y,
input[31:0] angle,
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
output reg [31:0] x_out,
output reg [31:0] y_out,
output reg [31:0] angle_out
\end{verbatim}
\end{latin}

وظیفه این ماژول این است که اگر $x$ و $y$ ورودی در ناحیه اول یا چهارم قرار نداشتند، از طریق تبدیل هایی که در بخش ریاضی نوشتیم، آن ها را به ناحیه اول یا چهارم منتقل کرده و برای حالتی که در ناحیه دوم باشند، زاویه اولیه خروجی را $90$ درجه و در حالتی که در ناحیه سوم باشند، زاویه اولیه خروجی را $270$ درجه (معادل $-90$ درجه) قرار بدهد.

\hrulefill

ماژول بعدی \lr{Scaler} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] number,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] answer
\end{verbatim}
\end{latin}

است. ورودی mode بیانگر این است که وضعیت برنامه در حالت CIRCULAR یا HYPERBOLIC یا LINEAR قرار دارد و براساس ثابت های \lr{CONSTANTS.v} مشخص می شود. وظیفه کلی این ماژول این است که عدد داده شده را متناسب با حالت داده شده در ضریب $K$ مناسب ضرب کند. برای حالت CIRCULAR این $K$ برابر $0.6073$ برای HYPERBOLIC برابر $1.2075$ و در حالت LINEAR برابر $1$ است. برای این که در ضرب کردن، از ماژول ضرب کننده استفاده نکنیم، برای ضرب در این اعداد از ترکیب شیفت و جمع استفاده می کنیم. به عنوان مثال
$$0.6073 \approx 2^{-1} + 2^{-4} + 2^{-5} + 2^{-7} + 2^{-7} + 2^{-10} + 2^{-11} + 2^{-12} + 2^{-13}$$
است در نتیجه، این جمع را به این شکل انجام می دهیم:

\begin{latin}
\begin{verbatim}
(number >>> 1) +(number >>>4) + (number>>>5)
+ (number>>>7) + (number>>>8) + (number>>>10) +
 (number>>>11) + (number>>>12) + (number>>>13);
\end{verbatim}
\end{latin}

در مورد $1.2075$ هم روش مشابهی اعمال می کنیم، با این تفاوت که وجود $1$ در عدد $1.2075$ یعنی یکی از بخش های جمع شونده، خود عدد اصلی بدون هیچ نوع شیفت اضافی است.

\hrulefill

ماژول بعدی \lr{X\_Calculator} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [1:0] mode,
input [31:0] y_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] x_out
\end{verbatim}
\end{latin}

سه ورودی اول که مشخص هستند. ورودی چهارم مربوط به همین است که در حالت CIRCULAR هستیم یا HYPERBOLIC یا LINEAR. ورودی پنجم که \lr{y\_shift} است، در اصل همان مقدار $y_i \times 2^{-i}$ در فرمول هاست که از ماژول اصلی به عنوان ورودی وارد این ماژول می شود. در نهایت هم clock را داریم که برای اجرای مرحله به مرحله سیستم به صورت \lr{Pipeline}، وجود کلاک که باعث ذخیره شدن و باقی ماندن مقادیر در رجیستر ها بشود، ضروری است.

درون این ماژول براساس ورودی های داده شده، محاسبات طبق فرمول های بخش ریاضی و براساس علامت $y$ انجام شده و مقدار جدید $x$ تحت نام \lr{x\_out} خروجی داده می شود.

\hrulefill
 

ماژول بعدی \lr{Y\_Calculator} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [31:0] x_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] y_out
\end{verbatim}
\end{latin}

این ماژول از نظر ورودی ها کاملا مشابه \lr{X\_Calculator} است، با این تفاوت که از آن جایی که نیازی به جز این که در این جا نیازی به دانستن mode نداریم و به عنوان ورودی داده نشده است. هدف این ماژول هم انجام محاسبات مربوط به $y$ است.

\hrulefill


ماژول بعدی \lr{Z\_Calculator} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] angle,
input [31:0] y,
input [31:0] lookup_table_amount,
input clock,
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
 output wire [31:0] angle_out
\end{verbatim}
\end{latin}

این ماژول هم از نظر عملکردی، مشابه دو ماژول قبلی است. تنها نکته این جاست که یک مقدار تحت نام \lr{lookup\_table\_amount} به آن ورودی داده می شود که در اصل، مقداری برابر با $2^{-i}$ یا $\arctan (2^{-1})$ یا
$\arctanh (2^{-1})$
است که از طریق یک تابع در ماژول اصلی تولید شده و به بسته به مود کلی سیستم، به عنوان ورودی به این ماژول که محاسبه کننده $Z$ یا همان $angle$ و زاویه بعدی است، داده می شود.

\hrulefill

فایل ماژول اصلی این پروژه، \lr{CORDIC\_Vector} نام دارد. ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input signed [31:0] x,
input signed [31:0] y,
input signed [31:0] angle,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
 output wire signed [31:0] rotated_x,
 output wire signed [31:0] rotated_y,
 output wire signed [31:0] final_angle
\end{verbatim}
\end{latin}

هستند. دلیل این که 32 بیتی در نظر گرفتیم، این بود که در حالت 16 بیتی، برای بسیاری از ورودی ها خروجی برنامه دقت کافی را نداشت.

پارامتر برنامه هم:

\begin{latin}
\begin{verbatim}
parameter NUMBER_OF_ITERATIONS = 17;
\end{verbatim}
\end{latin}

است. مقدار پیش فرض 17 از این رو قرار گرفته است که بهترین نتیجه ای که در تست های مختلف دریافت کردیم، برای ورودی و خروجی 32 بیتی، در حالت Vectoring مقدار 17، نتیجه مناسبی ارائه می داد و مقادیر بیش تر بعضا منجر به ایجاد Overflow در محاسبات شده و مقادیر کمتر هم دقت را کاهش می دادند.


ابتدا به تعداد Iteration های برنامه، یک آرایه از Vector های 32 بیتی Wire برای ایجاد ارتباطات میان خروجی $x,y,angle$ مراحل مختلف ایجاد کرده ایم که \lr{x\_prime}، \lr{y\_prime} و \lr{rotated\_angles} نام دارند.

در ابتدا، یک Instance از ماژول \lr{Quadrant\_Corrector} ساخته شده که وضعیت زاویه و ورودی های اصلی برنامه را مشخص کند و مقادیر خروجی آن، به مقادیر اندیس صفر  \lr{x\_prime}، \lr{y\_prime} و \lr{rotated\_angles} وصل می شوند.

سپس از طریق Generate به تعداد Iteration هایی که از طریق پارامتر تعریف شده است، instance از ماژول \lr{Y\_Calculator}، \lr{X\_Calculator} و \lr{Z\_Calculator} ساخته ایم. یکسری متغیر temp هم وجود دارند که مقادیر مربوط به $\arctan$ یا $\arctanh$ و همچنین شیفت داده شده $X$ و $Y$ به اندازه $i$ را که اندیس همان مرحله باشد، به عنوان وردی به این ماژول ها متصل کنند.

بعد از بخش Generate، دو Instance از \lr{Scaler} ساخته شده که خروجی های مرحله آخر ماژول ها که یعنی اندیس
$NUMBER\_OF\_ITERATIONS - 1$
ام
 \lr{x\_prime}،
  \lr{y\_prime} به آن ها وصل شده تا متناسب با mode با ضریب $K$ مشخص Scale بشوند.

در نهایت این خروجی ها به عنوان خروجی اصلی برنامه داده شده اند.

در انتهای این کد، یک تابع به نام Lookup وجود دارد که Index و mode را ورودی گرفته و براساس آن، مقدار متناسب را از بین جدول $\arctan$ یا $\arctanh$ یا $2^{-i}$ خروجی می دهد. دلیل این که از از تابع استفاده کردیم، این است که در اصل مقادیر این تابع، به عنوان یکسری ثابت که از طریق Mux انتخاب می شوند، در حین Instantiate شدن ماژول های درون Generate به آن ها داده می شوند و نیازی نیست که از یک ROM جداگانه استفاده کنیم. زیرا در صورت استفاده از ROM باید امکان خوانده شدن همزمان حدود 32 مقدار مختلف را در بدترین حالت برای آن فراهم می کردیم تا همه مراحل سیستم بتوانند به صورت Pipeline و مستقل از هم کار بکنند که هزینه اجرایی بالایی داشت و از این رو آن را به صورت تابع پیاده سازی کردیم.


\subsubsection{ROTATION}
بخش زیادی از ماژول های استفاده شده در این بخش، مشابه بخش قبل است اما برای کامل بودن گزارش، توضیحات آن ها مجددا مانند بخش قبل آورده شده است.




قبل از اشاره به ماژول های اصلی پروژه، می بایست به فایل ثوابت یا \lr{CONSTANTS.v} اشاره کنیم. در این فایل از طریق \lr{`define} سه ثابت به صورت زیر تعریف شده است:
\begin{latin}
\begin{verbatim}
`define CIRCULAR 2'b01
`define LINEAR 2'b00
`define HYPERBOLIC 2'b11
\end{verbatim}
\end{latin}

این فایل از طریق \lr{`include} در سایر ماژول ها قرار گرفته است.

ماژول ها را در دادامه به ترتیب Bottom-Up شرح می دهیم.

اولین ماژول \lr{Quadrant\_Corrector} است که در فایل هم نام خودش قرار دارد. 

 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] x,
input [31:0] y,
input[31:0] angle,
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
output reg [31:0] x_out,
output reg [31:0] y_out,
output reg [31:0] angle_out
\end{verbatim}
\end{latin}

وظیفه این ماژول این است که اگر زاویه داده شده در بازه
 $\frac{-\pi}{2} < angle < \frac{pi}{2}$
 یا به بیان دیگر،
 $270 < angle \leq 360$
 یا
 $0 \leq angle <90$
 قرار نداشت،
یعنی تبدیل متناسب با ناحیه اول و چهارم قرار نداشت، از طریق تبدیل هایی که در بخش ریاضی نوشتیم، آن ها را به ناحیه اول یا چهارم منتقل کرده و برای حالتی که در ناحیه دوم باشند، زاویه اولیه خروجی را $90$ درجه کم کرده و در حالتی که در ناحیه سوم باشند، زاویه اولیه خروجی را $90$ درجه افزایش بدهد (به بیان دیگر $270$ درجه کم کند) تا در ناحیه چهارم قرار بگیرد و متناسب با آن تغییرات را روی $x$ و $y$ هم اعمال کند.


\hrulefill

ماژول بعدی \lr{Scaler} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] number,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] answer
\end{verbatim}
\end{latin}

است. ورودی mode بیانگر این است که وضعیت برنامه در حالت CIRCULAR یا HYPERBOLIC یا LINEAR قرار دارد و براساس ثابت های \lr{CONSTANTS.v} مشخص می شود. وظیفه کلی این ماژول این است که عدد داده شده را متناسب با حالت داده شده در ضریب $K$ مناسب ضرب کند. برای حالت CIRCULAR این $K$ برابر $0.6073$ برای HYPERBOLIC برابر $1.2075$ و در حالت LINEAR برابر $1$ است. برای این که در ضرب کردن، از ماژول ضرب کننده استفاده نکنیم، برای ضرب در این اعداد از ترکیب شیفت و جمع استفاده می کنیم. به عنوان مثال
$$0.6073 \approx 2^{-1} + 2^{-4} + 2^{-5} + 2^{-7} + 2^{-7} + 2^{-10} + 2^{-11} + 2^{-12} + 2^{-13}$$
است در نتیجه، این جمع را به این شکل انجام می دهیم:

\begin{latin}
\begin{verbatim}
(number >>> 1) +(number >>>4) + (number>>>5)
+ (number>>>7) + (number>>>8) + (number>>>10) +
 (number>>>11) + (number>>>12) + (number>>>13);
\end{verbatim}
\end{latin}

در مورد $1.2075$ هم روش مشابهی اعمال می کنیم، با این تفاوت که وجود $1$ در عدد $1.2075$ یعنی یکی از بخش های جمع شونده، خود عدد اصلی بدون هیچ نوع شیفت اضافی است.

\hrulefill

ماژول بعدی \lr{X\_Calculator} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [1:0] mode,
input [31:0] y_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] x_out
\end{verbatim}
\end{latin}

سه ورودی اول که مشخص هستند. ورودی چهارم مربوط به همین است که در حالت CIRCULAR هستیم یا HYPERBOLIC یا LINEAR. ورودی پنجم که \lr{y\_shift} است، در اصل همان مقدار $y_i \times 2^{-i}$ در فرمول هاست که از ماژول اصلی به عنوان ورودی وارد این ماژول می شود. در نهایت هم clock را داریم که برای اجرای مرحله به مرحله سیستم به صورت \lr{Pipeline}، وجود کلاک که باعث ذخیره شدن و باقی ماندن مقادیر در رجیستر ها بشود، ضروری است.

درون این ماژول براساس ورودی های داده شده، محاسبات طبق فرمول های بخش ریاضی براساس علامت $angle$ که با توجه به فرمت خاصی که برای انکود کردن انتخاب کردیم، در بیت $31$ ام آن (اندیس $30$) قرار دارد، انجام شده و مقدار جدید $x$ تحت نام \lr{x\_out} خروجی داده می شود.

\hrulefill
 

ماژول بعدی \lr{Y\_Calculator} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input[31:0] x,
input[31:0] y,
input [31:0] angle,
input [31:0] x_shift,
input clock
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
output [31:0] y_out
\end{verbatim}
\end{latin}

این ماژول از نظر ورودی ها کاملا مشابه \lr{X\_Calculator} است، با این تفاوت که از آن جایی که نیازی به جز این که در این جا نیازی به دانستن mode نداریم و به عنوان ورودی داده نشده است. هدف این ماژول هم انجام محاسبات مربوط به $y$ است.

\hrulefill


ماژول بعدی \lr{Z\_Calculator} است که در فایل هم نام خودش قرار دارد.

 
 ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input [31:0] angle,
input [31:0] y,
input [31:0] lookup_table_amount,
input clock,
\end{verbatim}
\end{latin}

و خروجی آن:

\begin{latin}
\begin{verbatim}
 output wire [31:0] angle_out
\end{verbatim}
\end{latin}

این ماژول هم از نظر عملکردی، مشابه دو ماژول قبلی است. تنها نکته این جاست که یک مقدار تحت نام \lr{lookup\_table\_amount} به آن ورودی داده می شود که در اصل، مقداری برابر با $2^{-i}$ یا $\arctan (2^{-1})$ یا
$\arctanh (2^{-1})$
است که از طریق یک تابع در ماژول اصلی تولید شده و به بسته به مود کلی سیستم، به عنوان ورودی به این ماژول که محاسبه کننده $Z$ یا همان $angle$ و زاویه بعدی است، داده می شود.

\hrulefill

فایل ماژول اصلی این پروژه، \lr{CORDIC\_Rotation} نام دارد. ورودی های آن موارد زیر هستند:

\begin{latin}
\begin{verbatim}
input signed [31:0] x,
input signed [31:0] y,
input signed [31:0] angle,
input [1:0] mode
\end{verbatim}
\end{latin}

و خروجی های آن:

\begin{latin}
\begin{verbatim}
 output wire signed [31:0] rotated_x,
 output wire signed [31:0] rotated_y,
 output wire signed [31:0] final_angle
\end{verbatim}
\end{latin}

هستند. دلیل این که 32 بیتی در نظر گرفتیم، این بود که در حالت 16 بیتی، برای بسیاری از ورودی ها خروجی برنامه دقت کافی را نداشت.

پارامتر برنامه هم:

\begin{latin}
\begin{verbatim}
parameter NUMBER_OF_ITERATIONS = 29;
\end{verbatim}
\end{latin}


ابتدا به تعداد Iteration های برنامه، یک آرایه از Vector های 32 بیتی Wire برای ایجاد ارتباطات میان خروجی $x,y,angle$ مراحل مختلف ایجاد کرده ایم که \lr{x\_prime}، \lr{y\_prime} و \lr{rotated\_angles} نام دارند.

در ابتدا، یک Instance از ماژول \lr{Quadrant\_Corrector} ساخته شده که وضعیت زاویه و ورودی های اصلی برنامه را مشخص کند و مقادیر خروجی آن، به مقادیر اندیس صفر  \lr{x\_prime}، \lr{y\_prime} و \lr{rotated\_angles} وصل می شوند.

سپس از طریق Generate به تعداد Iteration هایی که از طریق پارامتر تعریف شده است، instance از ماژول \lr{Y\_Calculator}، \lr{X\_Calculator} و \lr{Z\_Calculator} ساخته ایم. یکسری متغیر temp هم وجود دارند که مقادیر مربوط به $\arctan$ یا $\arctanh$ و همچنین شیفت داده شده $X$ و $Y$ به اندازه $i$ را که اندیس همان مرحله باشد، به عنوان وردی به این ماژول ها متصل کنند.

بعد از بخش Generate، دو Instance از \lr{Scaler} ساخته شده که خروجی های مرحله آخر ماژول ها که یعنی اندیس
$NUMBER\_OF\_ITERATIONS - 1$
ام
 \lr{x\_prime}،
  \lr{y\_prime} به آن ها وصل شده تا متناسب با mode با ضریب $K$ مشخص Scale بشوند.

در نهایت این خروجی ها به عنوان خروجی اصلی برنامه داده شده اند.

در انتهای این کد، یک تابع به نام Lookup وجود دارد که Index و mode را ورودی گرفته و براساس آن، مقدار متناسب را از بین جدول $\arctan$ یا $\arctanh$ یا $2^{-i}$ خروجی می دهد. دلیل این که از از تابع استفاده کردیم، این است که در اصل مقادیر این تابع، به عنوان یکسری ثابت که از طریق Mux انتخاب می شوند، در حین Instantiate شدن ماژول های درون Generate به آن ها داده می شوند و نیازی نیست که از یک ROM جداگانه استفاده کنیم. زیرا در صورت استفاده از ROM باید امکان خوانده شدن همزمان حدود 32 مقدار مختلف را در بدترین حالت برای آن فراهم می کردیم تا همه مراحل سیستم بتوانند به صورت Pipeline و مستقل از هم کار بکنند که هزینه اجرایی بالایی داشت و از این رو آن را به صورت تابع پیاده سازی کردیم.



\newpage
\medskip


\bibliographystyle{unsrt-fa}
\bibliography{mybibliography}


\end{document}












